import React, { cloneElement, ReactNode, useEffect, useLayoutEffect, useRef, useState,CSSProperties } from "react";
import { v4 as uuid } from "uuid";
import { useKeyPress } from "src/platform/hooks";
import { observer } from "mobx-react-lite";


/** `getClone` is generating a clone of the target, adding accessibility features and blur and focus listeners.
 * - It sets the tabIndex on target, so it can be focused.
 * @param children - The wrapped component.
 * @param ariaLabel - A uuid string, set on the decoy as id for accessibility. Use for the targets 'aria-describedby'.
 * @param handleOnFocus - handles the focus event of the target
 * @param handleBlur - handles the blur event of the target.
 *
 * */
const getClone = (children, ariaLabel, handleOnFocus, handleOnBlur) => {
  return cloneElement(children, {
    "aria-describedby": ariaLabel,
    onFocus: handleOnFocus,
    onBlur: handleOnBlur,
    tabIndex: 0,
    ...children.props
  });
};

export type TooltipProps = {
  /** - The tooltip takes a string a number, any html element and any react element.*/
  tooltip: any;
  /** - A `boolean` representing the tooltip having an arrow pointing to the target. Default is 'true'. */
  arrow?: boolean;
  /** - left | right | top | bottom - Where the tooltip will appear in relation to its target. Default is 'bottom'. */
  position?: "left" | "right" | "top" | "bottom";
  /** - a custom style object to override any styles of the tooltip */
  style?: CSSProperties;
  /** - A method provided by withHover, since withHover is the outermost component of the HOC chain, its state can be shared with the whole chain.
   * - Target is used by many components, so withHover sets it. */
  setTarget?: (state) => void;
  /** - The `ref` of the target. Is generated by this component and setTarget delivers it to the whole chain. */
  target?: HTMLDivElement;
  /** - A `boolean` reflecting the current hover state of the target. provided by withHover HOC. */
  isHovering?: boolean;
  /** - A `boolean`, state established by withPortal, the outermost component that needs this value.
   * - Is representing the current state of the tooltip. Is used as a flag by withPortal to show and hide the tooltip.
   * - Is generated based on values of isHovering, isFocused, isReady.  */
  isOpen?: boolean;
  /** - The `setter` for isOpen, is established in withPortal. */
  setIsOpen?: (state) => void;
  /** - A `boolean` representing the current focus state of the target. On focus, isOpen becomes true.
   * - Established by with box, the outermost component depending on this value ( for tooltip position calculations ). */
  isFocused?: boolean;
  /** - The `setter` for `isFocused`. The focus listener is in this component.  Its handler is setting this state. */
  setIsFocused?: (state) => void;
  /** - The `setter` for `isHovering`. The mouseOver listener is in this component.  Its handler is setting this state. */
  setIsHovering?: (state) => void;
  /** - A `boolean` reflecting whether the tooltip positioning is ready. Set either by withContent, withPositioning or withBox, depending which part had to be rebuilt for this target. */
  isReady?: boolean;
  /** - The `setter` for isReady.  Is used in WithTooltip in the focus and blur listeners.
   * - Also in the global event listener to reset all tooltips after a button click.*/
  setIsReady?: (state) => void;
  /** - the `node` of the target component */
  children: ReactNode;
};

/**
 * WithTooltip is the base component of the tooltip HOC chain.
 *
 * @remarks This is the base for a chain of HOC.
 * - withHover(withWindowSize(withBox(withPositioning(withContent(withPortal(WithTooltip))))));
 * - `withHover` - Handles the hover event.
 * - `withWindowSize` - Handles resizing and scrolling.
 * - `withBox` - Handles tracking of the current position and dimensions of target.
 * - `withPositioning` - Handles translating the target position into the form need by tooltip.
 * - `withContent` - Handles generating the actual tooltip based on withBox and withPositioning results.
 * - `withPortal` - Handles showing and hiding the tooltip in a react portal.
 * - `WithTooltip` - Is this component the base of the chain.
 *
 * This component is the command center of the tooltip.
 * - It sets the open/close state.
 * - It listens for a focus/blur event on target.
 * - It listens for a click event on target.
 * - It listens to the global 'close tooltips' event.
 * - It listens for the Escape key, closing the tooltip when its pressed.
 * - It dispatches the global 'close tooltips event' when it detects a click on the target.
 * - It creates the target ref.
 * - it creates a clone of the target with accessibility features.
 * - it creates and places in the dom a decoy for accessibility, the decoy will be used in the accessibility tree to represent the tooltip.
 * it has role='tooltip', id=ariaLabel, and its content in the tooltip text.
 *
 * @example Integration of the tooltip component into the layout.
 * ```js
 * import {Tooltip} from 'components/shared/tooltip'
 * import {Button} from 'components/shared/button'
 * <Tooltip tooltip="tooltip text." arrow position="top"><Button label="target of the tooltip"/></Tooltip>
 * ```
 * @see {@link TooltipProps} for other currently supported props.
 */
export const WithTooltip = observer(({ style, arrow, isHovering, children, setTarget, target, isOpen, tooltip, setIsOpen, setIsFocused, setIsHovering, isFocused, isReady, setIsReady }: TooltipProps) => {
  /** sets the state for the label. Used as id on the decoy and as 'aria-describedby' on the target, connecting them.*/
  const [ariaLabel, setAriaLabel] = useState(uuid());

  /** TargetRef is first created on the decoy, then find its sibling to establish the target. */
  const targetRef = useRef<HTMLDivElement>(null);

  /** Handles focus/blur events. Flips the isFocused flag. */
  const handleOnFocus = () => {
    setIsFocused(true);
  };
  const handleOnBlur = () => {
    setIsFocused(false);
  };

  /** A hook to listen for the Escape key being pressed. Escape closes the tooltip. */
  const escKeyPressed = useKeyPress("Escape");

  /** Handles the Escape key event. Blurs the target, flips the isReady flag to false. */
  useEffect(() => {
    setIsFocused(false);
    setIsHovering(false);
    return () => {};
  }, [escKeyPressed, setIsHovering, setIsFocused]);

  /** Handles flipping the isOpen flag, based on the values of isHovering, isFocused and isReady flags. */
  useEffect(() => {
    if (isReady && (isHovering || isFocused)) {
      setIsOpen(true);
    } else {
      setIsOpen(false);
    }

    return () => {};
  }, [isHovering, setIsOpen, isOpen, isFocused, isReady]);


  useLayoutEffect(() =>
  {
    /** Handles a click on the target. This is a special event, since clicks are used as filters in few places, like the Totals in RelayDashboard.
     * This scrambles up the order and the identity of the targets. Everything needs to be reset. Also click focuses the target, but since it changed identity,
     * the focus event would show the wrong tooltip on the wrong place. global event is dispatched to flip all flags to false.
     */
    const handleTargetClick = () => {
      const event = new Event("close tooltips");
      document.dispatchEvent(event);
      setTarget(() => targetRef.current.nextElementSibling as HTMLDivElement);
    };
    const node = target;
    node?.addEventListener("click", handleTargetClick);
    return () => {
      node?.removeEventListener("click", handleTargetClick);
    };
  }, [target, setTarget]);

  useLayoutEffect(() =>
  {
    /** This is where the global event is handled and all flags flipped to false.
     */
    const handleGlobalEvent = () => {
      setIsReady(false);
      setIsOpen(false);
      setIsFocused(false);
      target?.blur();
    };
    document.addEventListener("close tooltips", handleGlobalEvent);
    return () => {
      document.removeEventListener("close tooltips", handleGlobalEvent);
    };
  }, [setIsOpen, setIsReady, setIsFocused, target]);


  useLayoutEffect(() =>
  {
    /** Here the target ref is being established, by looking for the sibling of the decoy div,=. */
    if (targetRef?.current && targetRef.current !== targetRef.current?.nextElementSibling) {
      setTarget(() => targetRef.current.nextElementSibling as HTMLDivElement);
    }
    return () => {};
  }, [targetRef, setTarget]);

  /** the clone is being generated outside of the component. TODO: see how it can be cached */
  const tempClone = getClone(children, ariaLabel, handleOnFocus, handleOnBlur);

  /** in the render return the decoy and the clone are being placed. As the base for this HOC chain. */
  return (
    <>
      <div ref={(el) => (targetRef.current = el)} style={{ display: "none", width: 0, height: 0, opacity: 0 }} id={ariaLabel} aria-label={tooltip} role="tooltip">
        {tooltip}
      </div>
      {tempClone}
    </>
  );
});

/** name is set explicitly, so it can be used in the react dev tools in Chrome. */
WithTooltip.displayName = 'Tooltip';